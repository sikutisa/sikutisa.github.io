---
tags: [computer science, os]
---

# Blocking and Non-Blocking & Synchronous and Asynchronous
## Blocking vs Non-Blocking
### Blocking
* **한 작업이 완료될 때까지 프로그램의 실행이 중지됨**
  * 예를 들어, 서버에 데이터를 요청하는 경우, 서버로부터 응답이 올 때까지 프로그램은 일반적으로 '대기' 상태
    * 이 시간 동안에는 프로그램이 다른 어떤 작업도 수행하지 않는다
  * CPU는 비효율적으로 사용됨
  * 프로그램의 전체 실행 시간은 서버의 응답 시간에 크게 의존

### Non-Blocking
* **한 작업이 완료되는 것을 기다리지 않고 다음 작업을 즉시 시작**
  * 예를 들어, 서버에 데이터를 요청한 후, 응답을 기다리는 대신 즉시 다른 작업을 시작할 수 있음
  * 이 방식은 CPU를 보다 효율적으로 사용하며, 프로그램의 전체 실행 시간을 단축시킬 수 있음
    * 그러나 이런 방식은 프로그램의 복잡성을 증가시킬 수 있음
    * 여러 작업이 동시에 실행되면서 데이터의 상태를 추적하고 제어하는 것이 더 어려워지기 때문

## Synchronous vs Asynchronous
### Synchronous(동기)
* **요청과 그에 대한 응답이 순차적으로 이루어짐**
  * 작업 A를 시작하고, 작업 A가 완료되면 그 다음 작업인 B를 시작
  * 프로그램의 흐름을 쉽게 추적할 수 있음
  * 앞선 작업이 시간이 오래 걸릴 경우 뒤따르는 작업들은 대기해야 하는 단점
  
### Asynchronous(비동기)
* **요청과 응답이 동시에 이루어질 수 있음**
  * 작업 A를 시작한 후, 작업 A의 완료를 기다리지 않고 바로 다음 작업 B를 시작하는 방식
  * 복잡한 작업을 병렬로 처리할 수 있어 효율적
  *  작업간의 의존성을 관리하거나 오류를 추적하는 것이 복잡해질 수 있음

## Blocking vs Non-Blocking 과 Synchronous vs Asynchronous
### 각각의 개념에 대한 개념 다시 정리
* Blocking vs Non-Blocking
  * Blocking
    * 호출된 함수가 자신의 작업을 완료할 때까지 제어권을 반환하지 않는다
    * 호출자는 결과가 준비될 때까지 대기해야 한다
  * Non-Blocking
    * 호출된 함수가 즉시 제어권을 반환한다
    * 호출자는 결과를 기다리지 않고 다음 작업을 계속할 수 있다
* Synchronous vs Asynchronous
  * Synchronous(동기)
    * 작업이 순차적으로 실행된다
    * 한 작업이 완료되면 다음 작업이 시작된다
  * Asynchronous(비동기)
    * 작업이 동시에 실행될 수 있다
    * 한 작업이 완료되기를 기다리지 않고 다음 작업을 시작할 수 있다

### 왜 헷갈릴까?
* Blocking과 Synchronous 방식이 모두 **대기**라는 개념을 포함하고 있기 때문
  * Blocking에서는 호출된 함수가 작업을 완료할 때까지 대기
  * Synchronous에서는 이전 작업이 완료될 때까지 다음 작업이 대기
* 그러나 서로 다른 개념이다
  * **Blocking은 호출자와 피호출자 간의 관계에 초점**
  * **Synchronous는 작업 간의 시간 관계에 초점**
* 서로 독립적인 개념이기에, 서로 결합돼 사용될 수 있음
  * e.g. Synchronous/Non-Blocking 방식에서는 작업이 순차적으로 실행되지만, 각 작업은 즉시 제어권을 반환하여 다음 작업이 시작할 수 있음

## 각 케이스별 예시
### Blocking-Synchronous
* HTTP 요청
  * 클라이언트가 서버에 요청을 보내면, 서버의 응답을 기다리는 동안 클라이언트는 다른 작업을 수행할 수 없음
  * 요청을 보낸 후 응답을 받을 때까지의 프로세스가 순차적으로 진행되며, 응답을 기다리는 동안 다른 작업을 수행하지 못하므로 Blocking 상태

### Non-Blocking-Synchronous
* UI
  * 사용자가 버튼을 클릭하면 해당 작업을 처리하고 동시에 다른 작업도 계속 진행할 수 있음
  * Synchronous(순차적인) 통신이지만, 응답을 기다리는 동안 다른 일을 계속 할 수 있는(Non-Blocking) 상황
* GUI 프로그래밍에서 이벤트 루프
  * 이벤트 루프는 이벤트가 발생하면 적절한 이벤트 핸들러를 동기적으로 호출하지만, 핸들러 실행 완료를 기다리지 않고 다음 이벤트를 체크
  * 순차적인 실행이지만, 다음 작업을 기다리지 않는 Non-Blocking 상태

### Blocking-Asynchronous
* 멀티스레드 프로그래밍에서 스레드가 락(lock)을 기다리는 경우
  * 여러 스레드가 동시에 실행되지만(Asynchronous), 특정 자원에 대한 접근을 제어하기 위해 락을 기다리는 경우(Blocked)
  * 복잡한 작업을 병렬로 처리할 수 있지만, 동기화 문제를 해결 필요

### Non-Blocking-Asynchronous
* 고성능 서버나 데이터베이스
  * 서버가 동시에 여러 요청을 처리하거나, 데이터베이스가 동시에 여러 쿼리를 실행할 떄 사용
  * Asynchronous(비동기적인) 통신이며, 한 요청의 처리가 끝날 때까지 다른 요청의 처리를 기다리지 않는(Non-Blocking) 상황
  * 높은 처리량을 달성할 수 있지만, 복잡한 로직을 관리해야 함
* Node.js의 I/O 처리
  * Node.js는 비동기적으로 I/O 요청을 처리하며, 요청이 완료되기를 기다리지 않고 다음 코드를 즉시 실행
  * 비동기적인 실행(Asynchronous)이며, I/O 요청의 완료를 기다리지 않는 Non-Blocking 상태

## Summary
* 이 네 가지 개념은 서버 응답 시간, CPU 사용률, 병렬 처리 가능성, 코드 복잡성 등 여러 요소를 고려하여 프로그램의 성능과 효율성을 향상시키는 데 중요한 역할을 한다
  * 따라서 이러한 요소들을 고려하여 상황에 맞는 최적의 방식을 선택해야 한다

